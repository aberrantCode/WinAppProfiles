

  # Windows Application Profiles v1 Implementation Plan

  ## Summary
  Build a greenfield Windows desktop app that auto-starts at logon and applies user-selected “Application Profiles” for process and service running state.
  packaging as MSIX, git flow feature/* -> dev -> main.

  ## Architecture and Scope
  1. Create solution layout:
  2. Use .NET 8 and DI (Microsoft.Extensions.Hosting) in desktop app startup.
  3. Implement logging with Serilog (file + rolling daily logs + structured context).
  4. Use SQLite with Dapper and migration runner (DbUp or equivalent).
  5. v1 service scope: start/stop only, no startup-type changes.

  ## Public Interfaces and Types

  1. IProfileService:
     CreateProfile, UpdateProfile, GetProfiles, ApplyProfile(profileId), PreviewProfile(profileId).
  2. IStateController:
     EnsureProcessState(ProcessTarget, DesiredState), EnsureServiceState(ServiceTarget, DesiredState).
     ScanInstalledApplications(), ScanServices(), GetNeedsReview(profileId).
  4. Core models:
     Profile, ProfileItem, DesiredState { Running, Stopped, Ignore }, TargetType { Application, Service }, ApplyResult.
  5. Identity rule:
     application key = ExecutablePath + ProcessName; service key = ServiceName.

  ## Data Model (SQLite)

  1. profiles(id, name, is_default, created_at, updated_at).
  3. apply_runs(id, profile_id, started_at, finished_at, status, summary_json).
  4. apply_run_items(id, run_id, profile_item_id, requested_state, actual_state, success, error_code, error_message).
  5. app_settings(key, value) for UI mode, startup task status, scan cadence.


  1. Simple mode:
     profile picker, Apply button, run summary, quick status chips.
  2. Advanced mode:
     editable grid for all profile items, per-item desired state, bulk actions.
  3. Needs Review panel:
     show only newly discovered apps/services not yet reviewed for a profile.
  2. Task configured At logon and Run with highest privileges.
  3. App manifest requests admin rights to satisfy chosen “always elevated” model.

  ## Testing and Acceptance

  1. Unit tests:
     state reconciliation logic, identity matching, failure policy, Needs Review filtering.
  2. Integration tests:
     SQLite repository, migrations, profile apply pipeline with mocked controllers.
  3. System acceptance scenarios:
     dev profile (stop printer/monitor/camera, start Docker/Ollama/Claude), mixed success/failure reporting, unknown app detection after software install, startup-at-logon
     behavior.
  4. Coverage gate:
     minimum 80% for Core and Infrastructure projects.

  ## Git Workflow and Delivery

  1. Initialize repo with main and dev.
  2. Work only in feature/<topic> branches; PR target is dev.
  3. Release PRs dev -> main only after test pass and manual smoke checklist.
  4. PR requirements:
     problem statement, behavior changes, test evidence, screenshots for UI changes, linked issue/task.
  5. Conventional commit format:
     feat:, fix:, test:, chore:, docs:.

  ## Assumptions and Defaults

  1. Target users have local admin rights, required by always-elevated + service control.
  2. MSIX signing/cert pipeline will be available in CI before first production release.
  3. Process control is local-machine only; no remote orchestration in v1.
  4. No automatic profile switching in v1; switching is user-triggered from UI.

